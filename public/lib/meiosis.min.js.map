{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///meiosis.min.js","webpack:///webpack/bootstrap 91984feeba07e07e1b98","webpack:///./~/ramda/src/internal/_isPlaceholder.js","webpack:///./~/ramda/src/internal/_arity.js","webpack:///./~/ramda/src/internal/_curry1.js","webpack:///./src/meiosis.ts","webpack:///./~/flyd/lib/index.js","webpack:///./~/ramda/src/curryN.js","webpack:///./~/ramda/src/internal/_curry2.js","webpack:///./~/ramda/src/internal/_curryN.js","webpack:///./src/index.ts"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","a","fn","apply","arguments","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","Error","_isPlaceholder","f1","length","newInstance","run","params","initialModel","modelChanges","streams","allStreams","lastStream","scan","model","modelChange","scannerStream","scannerName","push","stream","mappers","forEach","mapper","mapperName","getName","mapperFn","getFn","map","render","on","devtool","window","copy_1","copy","JSON","parse","stringify","bufferedValues_1","devtoolInitialized_1","sendValues_1","changes_1","Date","lastChange_1","addEventListener","evt","data","type","sendValuesBack","values","postMessage","change","update","namedStream","flyd","combine","merge","mergeAll","merged","undefined","keys","instance","isFunction","obj","constructor","trueFn","deps","depEndStreams","endStream","createDependentStream","end","depsChanged","fnArgs","concat","listeners","addListeners","updateStream","boundMap","f","ap","s2","s1","self","val","streamToString","createStream","updateStreamValue","hasVal","vals","queued","of","toString","depsMet","shouldUpdate","initialDepsNotMet","every","inStream","toUpdate","returnVal","flushing","flushUpdate","updateDeps","list","findDeps","orderNextIdx","order","shift","then","markListeners","lists","removeListener","idx","indexOf","detachDeps","StreamTransformer","curryN","initialValue","toJSON","isStream","immediate","endsOn","endS","acc","ns","changed","transduce","xform","source","res","v","_arity","_curry1","_curry2","_curryN","f2","b","_b","_a","received","combined","argsIdx","left","combinedIdx","result","__export"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,UAAAH,GACA,gBAAAC,SACAA,QAAA,QAAAD,IAEAD,EAAA,QAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAE,EAAAF,EACAG,GAAA,EACAV,WAUA,OANAK,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,GAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KA+DA,OAnCAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAG,EAAA,SAAAK,GAA2C,MAAAA,IAG3CR,EAAAS,EAAA,SAAAf,EAAAgB,EAAAC,GACAX,EAAAY,EAAAlB,EAAAgB,IACAG,OAAAC,eAAApB,EAAAgB,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAX,EAAAkB,EAAA,SAAAvB,GACA,GAAAgB,GAAAhB,KAAAwB,WACA,WAA2B,MAAAxB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAK,GAAAS,EAAAE,EAAA,IAAAA,GACAA,GAIAX,EAAAY,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAlB,KAAAe,EAAAC,IAGtDrB,EAAAwB,EAAA,GAGAxB,IAAAyB,EAAA,KDgBM,SAAU9B,EAAQD,GEhFxBC,EAAAD,QAAA,SAAAgC,GACA,aAAAA,GACA,gBAAAA,IACAA,EAAA,mCFwFM,SAAU/B,EAAQD,GG3FxBC,EAAAD,QAAA,SAAAwB,EAAAS,GAEA,OAAAT,GACA,yBAA+B,MAAAS,GAAAC,MAAA9B,KAAA+B,WAC/B,wBAAAC,GAAiC,MAAAH,GAAAC,MAAA9B,KAAA+B,WACjC,wBAAAC,EAAAC,GAAqC,MAAAJ,GAAAC,MAAA9B,KAAA+B,WACrC,wBAAAC,EAAAC,EAAAC,GAAyC,MAAAL,GAAAC,MAAA9B,KAAA+B,WACzC,wBAAAC,EAAAC,EAAAC,EAAAC,GAA6C,MAAAN,GAAAC,MAAA9B,KAAA+B,WAC7C,wBAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAAiD,MAAAP,GAAAC,MAAA9B,KAAA+B,WACjD,wBAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAAqD,MAAAR,GAAAC,MAAA9B,KAAA+B,WACrD,wBAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAAyD,MAAAT,GAAAC,MAAA9B,KAAA+B,WACzD,wBAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAA6D,MAAAV,GAAAC,MAAA9B,KAAA+B,WAC7D,wBAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAAiE,MAAAX,GAAAC,MAAA9B,KAAA+B,WACjE,yBAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAAsE,MAAAZ,GAAAC,MAAA9B,KAAA+B,WACtE,kBAAAW,OAAA,kFHoGM,SAAU7C,EAAQD,EAASM,GIlHjC,GAAAyC,GAAAzC,EAAA,EAWAL,GAAAD,QAAA,SAAAiC,GACA,eAAAe,GAAAhB,GACA,WAAAG,UAAAc,QAAAF,EAAAf,GACAgB,EAEAf,EAAAC,MAAA9B,KAAA+B,cJ4HM,SAAUlC,EAAQD,EAASM,GAEjC,YKvEA,SAAA4C,KACE,GAAMC,GAAM,SAACC,GACX,IAAKA,EAAOC,eAAiBD,EAAOE,aAClC,KAAM,IAAIR,OAAM,gDAElB,IAAMS,MACAC,KAEFC,EAAwBzD,EAAA0D,KAAK,SAACC,EAAUC,GAAgC,MAAAA,GAAYD,IACtFP,EAAOC,aAAcD,EAAOE,cAExBO,EAAgBJ,EAChBK,EAAc,cACpBP,GAAQO,GAAeL,EACvBD,EAAWO,MAAO/C,KAAM8C,EAAaE,OAAQP,KAE5CL,EAAOa,aAAeC,QAAQ,SAAAC,GAC7B,GAAMC,GAAqBC,EAAQF,GAC7BG,EAA6BC,EAAMJ,EAEzCV,GAAazD,EAAAwE,IAAIF,EAAUb,GAC3BW,IAAeb,EAAQa,GAAcX,GACrCD,EAAWO,MAAO/C,KAAOoD,GAAc,GAAKJ,OAAQP,KAGtD,IAAMgB,GAAsBzE,EAAAgE,QAkB1BhE,GAAA0E,GAAGD,EAAQhB,GAGbF,EAAgB,OAAIkB,CAEpB,IAAME,GAAmBC,QAAUA,OAAuC,8BAC1E,IAAID,EAAS,CACX,GAAME,GAAYzB,EAAO0B,MAAQ,SAAEnB,GAAa,MAAAoB,MAAKC,MAAMD,KAAKE,UAAUtB,KACpEuB,KACFC,GAA8B,EAC5BC,EAA8BpF,EAAAgE,QAAO,GAEvCqB,EAAwBrF,EAAAgE,OAAO,GAAIsB,OACnCC,EAAmBF,GACvBrF,GAAA0E,GAAG,WAAM,MAAAW,GAAQ,GAAIC,QAASlC,EAAOE,cAErCsB,OAAOY,iBAAiB,UAAW,SAAAC,GACX,yBAAlBA,EAAIC,KAAKC,MACXP,EAAWK,EAAIC,KAAKE,gBACpB/B,EAAc4B,EAAIC,KAAK/B,QAEE,wBAAlB8B,EAAIC,KAAKC,OAChBR,GAAqB,EACrBD,EAAehB,QAAQ,SAAA2B,GAAU,MAAAjB,QAAOkB,aAAcH,KAAM,iBAAkBE,OAAMA,GAAI,UAI5F7F,EAAA0E,GAAG,WACD,GAAMqB,GAAeV,IACfW,EAAkBD,IAAWR,CACnCA,GAAaQ,CAEb,IAAMF,GAA4BrC,EAAWgB,IAAI,SAACyB,GAChD,OAAGjF,KAAMiF,EAAYjF,KAAMF,MAAO+D,EAAKoB,EAAYjC,YAEjDoB,OACED,EACFP,OAAOkB,aAAcH,KAAM,iBAAkBE,OAAMA,EAAEG,OAAMA,GAAI,KAG/Dd,EAAenB,KAAK8B,KAGvBpC,GAGL,MAAOF,GAGT,QACEJ,IAAGA,GAlKP,GAAA+C,GAAA5F,EAAA,EAiDEN,GAAAmG,QAMED,EAAIC,QALNnG,EAAAwE,IAKE0B,EAAI1B,IAJNxE,EAAAoG,MAIEF,EAAIE,MAHNpG,EAAA0E,GAGEwB,EAAIxB,GAFN1E,EAAA0D,KAEEwC,EAAIxC,KADN1D,EAAAgE,OACEkC,EAAIlC,OAEKhE,EAAAqG,SAAW,SAAC9C,GACvB,GAAM+C,GAAStG,EAAAgE,QAEf,OADAT,GAAQW,QAAQ,SAAAnC,GAAK,MAAA/B,GAAAwE,IAAI8B,EAAQvE,KAC1BuE,EAGT,IAAMjC,GAAU,SAACvD,GAAe,MAAiB,kBAAVA,GAAuByF,OAAYpF,OAAOqF,KAAK1F,GAAO,IACvFyD,EAAQ,SAACzD,GACb,GAAME,GAAOqD,EAAQvD,EACrB,OAAOE,GAAOF,EAAME,GAAQF,EAwG5Bd,GAAAkD,aAJF,IAAMuD,GAAWvD,IACXC,EAAMsD,EAAStD,GAInBnD,GAAAmD,OLuDI,SAAUlD,EAAQD,EAASM,GAEjC,YMjOA,SAAAoG,GAAAC,GACA,SAAAA,KAAAC,aAAAD,EAAAhG,MAAAgG,EAAAzE,OAEA,QAAA2E,KAAmB,SA0DnB,QAAAV,GAAAlE,EAAAsB,GACA,GAAA9C,GAAAsB,EAAA+E,EAAAC,EACAC,EAAAC,KAAAJ,EAEA,KADAC,KAAYC,KACZtG,EAAA,EAAaA,EAAA8C,EAAAN,SAAoBxC,EACjC8F,SAAAhD,EAAA9C,KACAqG,EAAA/C,KAAAR,EAAA9C,IACA8F,SAAAhD,EAAA9C,GAAAyG,KAAAH,EAAAhD,KAAAR,EAAA9C,GAAAyG,KAWA,OARAnF,GAAAkF,EAAAH,EAAA7E,GACAF,EAAAoF,eACApF,EAAAqF,OAAArF,EAAA+E,KAAAO,QAAAtF,IAAAoF,cACApF,EAAAmF,IAAAF,EACAA,EAAAM,UAAAvD,KAAAhC,GACAwF,EAAAR,EAAAC,GACAA,EAAAF,KAAAC,EACAS,EAAAzF,GACAA,EAwPA,QAAA0F,GAAAC,GAAsB,MAAAxB,GAAA1B,IAAAkD,EAAAtH,MAwBtB,QAAAuH,GAAAC,GACA,GAAAC,GAAAzH,IACA,OAAA+F,GAAA,SAAA0B,EAAAD,EAAAE,GAAyCA,EAAAD,EAAAE,IAAAH,EAAAG,QAAwBF,EAAAD,IAQjE,QAAAI,KACA,gBAAA5H,KAAA2H,IAAA,IAiCA,QAAAE,KACA,QAAAlG,GAAAP,GACA,WAAAW,UAAAc,OAAAlB,EAAAgG,KACAG,EAAAnG,EAAAP,GACAO,GAYA,MAVAA,GAAAoG,QAAA,EACApG,EAAAgG,IAAAxB,OACAxE,EAAAqG,QACArG,EAAAuF,aACAvF,EAAAsG,QAAA,EACAtG,EAAAmF,IAAAX,OACAxE,EAAAyC,IAAAiD,EACA1F,EAAA4F,KACA5F,EAAAuG,GAAApC,EAAAlC,OACAjC,EAAAwG,SAAAP,EACAjG,EAWA,QAAAkF,GAAAH,EAAA7E,GACA,GAAAF,GAAAkG,GAOA,OANAlG,GAAAE,KACAF,EAAA+E,OACA/E,EAAAyG,SAAA,EACAzG,EAAAoF,YAAAL,EAAA7D,OAAA,KAAAsD,OACAxE,EAAA0G,cAAA,EACAlB,EAAAT,EAAA/E,GACAA,EASA,QAAA2G,GAAA1E,GAIA,MAHAA,GAAAwE,QAAAxE,EAAA8C,KAAA6B,MAAA,SAAA5G,GACA,MAAAA,GAAAoG,UAEAnE,EAAAwE,QAQA,QAAAhB,GAAAzF,GACA,KAAAA,EAAAyG,WAAA,GAAAE,EAAA3G,IACAwE,SAAAxE,EAAAmF,KAAAnF,EAAAmF,IAAAa,OAAA,GADA,CAEA,GAAAxB,SAAAqC,EAEA,WADAC,GAAA9E,KAAAhC,EAGA6G,GAAA7G,EACAA,EAAAoF,cAAApF,EAAAqF,OAAArF,EAAAqF,OAAAnE,OAAA,GAAAlB,EAAAoF,YACA,IAAA2B,GAAA/G,EAAAE,GAAAC,MAAAH,EAAAE,GAAAF,EAAAqF,OACAb,UAAAuC,GACA/G,EAAA+G,GAEAF,EAAArC,OACAA,SAAAxE,EAAAoF,cAAApF,EAAAoF,gBACApF,EAAA0G,cAAA,EACAM,KAAA,GAAAC,KAQA,QAAAC,GAAAlH,GACA,GAAAtB,GAAAS,EAAAgI,EACA5B,EAAAvF,EAAAuF,SACA,KAAA7G,EAAA,EAAaA,EAAA6G,EAAArE,SAAsBxC,EACnCyI,EAAA5B,EAAA7G,GACAyI,EAAAhC,MAAAnF,EACAiF,EAAAkC,IAEA3C,SAAA2C,EAAA/B,aAAA+B,EAAA/B,YAAApD,KAAAhC,GACAmH,EAAAT,cAAA,EACAU,EAAAD,GAGA,MAAQE,GAAA,IAAmBA,EAC3BlI,EAAAmI,EAAAD,GACAlI,EAAAuH,gBAAA,GAAAjB,EAAAtG,GACAA,EAAAmH,QAAA,EAUA,QAAAc,GAAApH,GACA,GAAAtB,GACA6G,EAAAvF,EAAAuF,SACA,IAAAvF,EAAAsG,UAAA,GAEA,IADAtG,EAAAsG,QAAA,EACA5H,EAAA,EAAeA,EAAA6G,EAAArE,SAAsBxC,EACrC0I,EAAA7B,EAAA7G,GAEA4I,KAAAD,GAAArH,GAOA,QAAAiH,KAEA,IADAD,GAAA,EACAF,EAAA5F,OAAA,IACA,GAAAlB,GAAA8G,EAAAS,OACAvH,GAAAqG,KAAAnF,OAAA,IAAAlB,EAAAgG,IAAAhG,EAAAqG,KAAAkB,SACAL,EAAAlH,GAEAgH,GAAA,EASA,QAAAb,GAAAnG,EAAAP,GACA,MAAA+E,UAAA/E,GAAA,OAAAA,GAAAkF,EAAAlF,EAAA+H,UACA/H,GAAA+H,KAAAxH,IAGAA,EAAAgG,IAAAvG,EACAO,EAAAoG,QAAA,OACA5B,SAAAqC,GACAG,GAAA,EACAE,EAAAlH,GACA8G,EAAA5F,OAAA,EAAA+F,IAA2CD,GAAA,GACxCH,IAAA7G,EACHyH,EAAAzH,IAAAuF,YAEAvF,EAAAqG,KAAArE,KAAAvC,GACAqH,EAAA9E,KAAAhC,MAOA,QAAAyH,GAAAzH,EAAA0H,GACA,GAAAhJ,GAAAyI,CACA,KAAAzI,EAAA,EAAaA,EAAAgJ,EAAAxG,SAAkBxC,EAC/ByI,EAAAO,EAAAhJ,GACAyI,EAAAhC,MAAAnF,GACAwE,SAAA2C,EAAA/B,aACA+B,EAAA/B,YAAApD,KAAAhC,GAEAmH,EAAAT,cAAA,GAEAzB,EAAAkC,GAWA,QAAA3B,GAAAT,EAAA/E,GACA,OAAAtB,GAAA,EAAiBA,EAAAqG,EAAA7D,SAAiBxC,EAClCqG,EAAArG,GAAA6G,UAAAvD,KAAAhC,GAUA,QAAA2H,GAAA3H,EAAAuF,GACA,GAAAqC,GAAArC,EAAAsC,QAAA7H,EACAuF,GAAAqC,GAAArC,IAAArE,OAAA,GACAqE,EAAArE,SAQA,QAAA4G,GAAA9H,GACA,OAAAtB,GAAA,EAAiBA,EAAAsB,EAAA+E,KAAA7D,SAAmBxC,EACpCiJ,EAAA3H,IAAA+E,KAAArG,GAAA6G,UAEAvF,GAAA+E,KAAA7D,OAAA,EAOA,QAAA+D,GAAAjF,GACAwE,SAAAxE,EAAA+E,MAAA+C,EAAA9H,GACAwE,SAAAxE,EAAAmF,KAAA2C,EAAA9H,EAAAmF,KAOA,QAAA4C,MA7mBA,GAUAlB,GAVAmB,EAAAzJ,EAAA,GASAuI,KAEAQ,KACAD,GAAA,EACAL,GAAA,EAGA7C,IAiBAA,GAAAlC,OAAA,SAAAgG,GACA,GAAAhD,GAAAC,KAAAJ,GACA9E,EAAAkG,GAQA,OAPAlG,GAAAmF,IAAAF,EACAjF,EAAAqF,UACAJ,EAAAM,UAAAvD,KAAAhC,GACAA,EAAAkI,OAAA,WACA,MAAAlI,MAEAI,UAAAc,OAAA,GAAAlB,EAAAiI,GACAjI,GAoBAmE,EAAAC,QAAA4D,EAAA,EAAA5D,GAqCAD,EAAAgE,SAAA,SAAAlG,GACA,MAAA0C,GAAA1C,IAAA,UAAAA,IA4BAkC,EAAAiE,UAAA,SAAApI,GAKA,MAJAA,GAAAyG,WAAA,IACAzG,EAAAyG,SAAA,EACAhB,EAAAzF,IAEAA,GAqBAmE,EAAAkE,OAAA,SAAAC,EAAAtI,GAIA,MAHA8H,GAAA9H,EAAAmF,KACAmD,EAAA/C,UAAAvD,KAAAhC,EAAAmF,KACAnF,EAAAmF,IAAAJ,KAAA/C,KAAAsG,GACAtI,GAqBAmE,EAAA1B,IAAAuF,EAAA,WAAArC,EAAA3F,GACA,MAAAoE,GAAA,SAAApE,EAAA+F,GAAoCA,EAAAJ,EAAA3F,EAAAgG,QAAkBhG,MAiBtDmE,EAAAxB,GAAAqF,EAAA,WAAArC,EAAA3F,GACA,MAAAoE,GAAA,SAAApE,GAA8B2F,EAAA3F,EAAAgG,OAAYhG,MAqB1CmE,EAAAxC,KAAAqG,EAAA,WAAArC,EAAA4C,EAAAvI,GACA,GAAAwI,GAAApE,EAAA,SAAApE,EAAA+F,GACAA,EAAAwC,EAAA5C,EAAA4C,EAAAvI,EAAAgG,QACGhG,GAEH,OADAwI,GAAApC,QAAAoC,EAAAD,GACAC,IAqBArE,EAAAE,MAAA2D,EAAA,WAAAlC,EAAAD,GACA,GAAA7F,GAAAmE,EAAAiE,UAAAhE,EAAA,SAAA0B,EAAAD,EAAAE,EAAA0C,GACAA,EAAA,GACA1C,EAAA0C,EAAA,MACK3C,EAAAM,OACLL,EAAAD,EAAAE,KACKH,EAAAO,QACLL,EAAAF,EAAAG,OAEGF,EAAAD,IAIH,OAHA1B,GAAAkE,OAAAjE,EAAA,WACA,WACG0B,EAAAX,IAAAU,EAAAV,MAAAnF,GACHA,IAwBAmE,EAAAuE,UAAAV,EAAA,WAAAW,EAAAC,GAEA,MADAD,KAAA,GAAAZ,IACA3D,EAAA,SAAAwE,EAAA7C,GACA,GAAA8C,GAAAF,EAAA,qBAAAnE,OAAAoE,EAAA5C,IACA,OAAA6C,MAAA,8BACA9C,EAAAZ,KAAA,GACA0D,EAAA,uBAEAA,IAEGD,MAkBHzE,EAAA6D,SAuTAD,EAAAlI,UAAA,kCACAkI,EAAAlI,UAAA,oCACAkI,EAAAlI,UAAA,8BAAAG,EAAA8I,GAAmE,MAAAA,IAEnE5K,EAAAD,QAAAkG,GN4OM,SAAUjG,EAAQD,EAASM,GOh2BjC,GAAAwK,GAAAxK,EAAA,GACAyK,EAAAzK,EAAA,GACA0K,EAAA1K,EAAA,GACA2K,EAAA3K,EAAA,EA6CAL,GAAAD,QAAAgL,EAAA,SAAA/H,EAAAhB,GACA,WAAAgB,EACA8H,EAAA9I,GAEA6I,EAAA7H,EAAAgI,EAAAhI,KAAAhB,OPw2BM,SAAUhC,EAAQD,EAASM,GQ55BjC,GAAAyK,GAAAzK,EAAA,GACAyC,EAAAzC,EAAA,EAWAL,GAAAD,QAAA,SAAAiC,GACA,eAAAiJ,GAAAlJ,EAAAmJ,GACA,OAAAhJ,UAAAc,QACA,OACA,MAAAiI,EACA,QACA,MAAAnI,GAAAf,GAAAkJ,EACAH,EAAA,SAAAK,GAAqC,MAAAnJ,GAAAD,EAAAoJ,IACrC,SACA,MAAArI,GAAAf,IAAAe,EAAAoI,GAAAD,EACAnI,EAAAf,GAAA+I,EAAA,SAAAM,GAAyD,MAAApJ,GAAAoJ,EAAAF,KACzDpI,EAAAoI,GAAAJ,EAAA,SAAAK,GAAyD,MAAAnJ,GAAAD,EAAAoJ,KACzDnJ,EAAAD,EAAAmJ,ORs6BM,SAAUlL,EAAQD,EAASM,GS97BjC,GAAAwK,GAAAxK,EAAA,GACAyC,EAAAzC,EAAA,EAaAL,GAAAD,QAAA,QAAAiL,GAAAhI,EAAAqI,EAAArJ,GACA,kBAKA,IAJA,GAAAsJ,MACAC,EAAA,EACAC,EAAAxI,EACAyI,EAAA,EACAA,EAAAJ,EAAArI,QAAAuI,EAAArJ,UAAAc,QAAA,CACA,GAAA0I,EACAD,GAAAJ,EAAArI,UACAF,EAAAuI,EAAAI,KACAF,GAAArJ,UAAAc,QACA0I,EAAAL,EAAAI,IAEAC,EAAAxJ,UAAAqJ,GACAA,GAAA,GAEAD,EAAAG,GAAAC,EACA5I,EAAA4I,KACAF,GAAA,GAEAC,GAAA,EAEA,MAAAD,IAAA,EAAAxJ,EAAAC,MAAA9B,KAAAmL,GACAT,EAAAW,EAAAR,EAAAhI,EAAAsI,EAAAtJ,OTu8BM,SAAUhC,EAAQD,EAASM,GAEjC,YAEA,SAASsL,GAAShL,GACd,IAAK,GAAIkB,KAAKlB,GAAQZ,EAAQ6B,eAAeC,KAAI9B,EAAQ8B,GAAKlB,EAAEkB,IUj/BpE8J,EAAAtL,EAAA","file":"meiosis.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"meiosis\"] = factory();\n\telse\n\t\troot[\"meiosis\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"meiosis\"] = factory();\n\telse\n\t\troot[\"meiosis\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = function _isPlaceholder(a) {\n  return a != null &&\n         typeof a === 'object' &&\n         a['@@functional/placeholder'] === true;\n};\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = function _arity(n, fn) {\n  /* eslint-disable no-unused-vars */\n  switch (n) {\n    case 0: return function() { return fn.apply(this, arguments); };\n    case 1: return function(a0) { return fn.apply(this, arguments); };\n    case 2: return function(a0, a1) { return fn.apply(this, arguments); };\n    case 3: return function(a0, a1, a2) { return fn.apply(this, arguments); };\n    case 4: return function(a0, a1, a2, a3) { return fn.apply(this, arguments); };\n    case 5: return function(a0, a1, a2, a3, a4) { return fn.apply(this, arguments); };\n    case 6: return function(a0, a1, a2, a3, a4, a5) { return fn.apply(this, arguments); };\n    case 7: return function(a0, a1, a2, a3, a4, a5, a6) { return fn.apply(this, arguments); };\n    case 8: return function(a0, a1, a2, a3, a4, a5, a6, a7) { return fn.apply(this, arguments); };\n    case 9: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) { return fn.apply(this, arguments); };\n    case 10: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) { return fn.apply(this, arguments); };\n    default: throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n  }\n};\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _isPlaceholder = __webpack_require__(0);\n\n\n/**\n * Optimized internal one-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curry1(fn) {\n  return function f1(a) {\n    if (arguments.length === 0 || _isPlaceholder(a)) {\n      return f1;\n    } else {\n      return fn.apply(this, arguments);\n    }\n  };\n};\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar flyd = __webpack_require__(4);\nexports.combine = flyd.combine, exports.map = flyd.map, exports.merge = flyd.merge, exports.on = flyd.on, exports.scan = flyd.scan, exports.stream = flyd.stream;\nexports.mergeAll = function (streams) {\n    var merged = exports.stream();\n    streams.forEach(function (s) { return exports.map(merged, s); });\n    return merged;\n};\nvar getName = function (value) { return typeof value === \"function\" ? undefined : Object.keys(value)[0]; };\nvar getFn = function (value) {\n    var name = getName(value);\n    return name ? value[name] : value;\n};\nfunction newInstance() {\n    var run = function (params) {\n        if (!params.initialModel || !params.modelChanges) {\n            throw new Error(\"Please specify initialModel and modelChanges.\");\n        }\n        var streams = {};\n        var allStreams = [];\n        var lastStream = exports.scan(function (model, modelChange) { return modelChange(model); }, params.initialModel, params.modelChanges);\n        var scannerStream = lastStream;\n        var scannerName = \"modelChanges\";\n        streams[scannerName] = lastStream;\n        allStreams.push({ name: scannerName, stream: lastStream });\n        (params.mappers || []).forEach(function (mapper) {\n            var mapperName = getName(mapper);\n            var mapperFn = getFn(mapper);\n            lastStream = exports.map(mapperFn, lastStream);\n            mapperName && (streams[mapperName] = lastStream);\n            allStreams.push({ name: (mapperName || \"\"), stream: lastStream });\n        });\n        var render = exports.stream();\n        exports.on(render, lastStream);\n        streams[\"render\"] = render;\n        var devtool = window && window[\"__MEIOSIS_TRACER_GLOBAL_HOOK__\"];\n        if (devtool) {\n            var copy_1 = params.copy || (function (model) { return JSON.parse(JSON.stringify(model)); });\n            var bufferedValues_1 = [];\n            var devtoolInitialized_1 = false;\n            var sendValues_1 = exports.stream(true);\n            var changes_1 = exports.stream(new Date());\n            var lastChange_1 = changes_1();\n            exports.on(function () { return changes_1(new Date()); }, params.modelChanges);\n            window.addEventListener(\"message\", function (evt) {\n                if (evt.data.type === \"MEIOSIS_RENDER_MODEL\") {\n                    sendValues_1(evt.data.sendValuesBack);\n                    scannerStream(evt.data.model);\n                }\n                else if (evt.data.type === \"MEIOSIS_TRACER_INIT\") {\n                    devtoolInitialized_1 = true;\n                    bufferedValues_1.forEach(function (values) { return window.postMessage({ type: \"MEIOSIS_VALUES\", values: values }, \"*\"); });\n                }\n            });\n            exports.on(function () {\n                var change = changes_1();\n                var update = change !== lastChange_1;\n                lastChange_1 = change;\n                var values = allStreams.map(function (namedStream) {\n                    return ({ name: namedStream.name, value: copy_1(namedStream.stream()) });\n                });\n                if (sendValues_1()) {\n                    if (devtoolInitialized_1) {\n                        window.postMessage({ type: \"MEIOSIS_VALUES\", values: values, update: update }, \"*\");\n                    }\n                    else {\n                        bufferedValues_1.push(values);\n                    }\n                }\n            }, lastStream);\n        }\n        return streams;\n    };\n    return {\n        run: run\n    };\n}\nexports.newInstance = newInstance;\nvar instance = newInstance();\nvar run = instance.run;\nexports.run = run;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar curryN = __webpack_require__(5);\n\n// Utility\nfunction isFunction(obj) {\n  return !!(obj && obj.constructor && obj.call && obj.apply);\n}\nfunction trueFn() { return true; }\n\n// Globals\nvar toUpdate = [];\nvar inStream;\nvar order = [];\nvar orderNextIdx = -1;\nvar flushing = false;\n\n/** @namespace */\nvar flyd = {}\n\n// /////////////////////////// API ///////////////////////////////// //\n\n/**\n * Creates a new stream\n *\n * __Signature__: `a -> Stream a`\n *\n * @name flyd.stream\n * @param {*} initialValue - (Optional) the initial value of the stream\n * @return {stream} the stream\n *\n * @example\n * var n = flyd.stream(1); // Stream with initial value `1`\n * var s = flyd.stream(); // Stream with no initial value\n */\nflyd.stream = function(initialValue) {\n  var endStream = createDependentStream([], trueFn);\n  var s = createStream();\n  s.end = endStream;\n  s.fnArgs = [];\n  endStream.listeners.push(s);\n  s.toJSON = function() {\n    return s();\n  };\n  if (arguments.length > 0) s(initialValue);\n  return s;\n}\n\n/**\n * Create a new dependent stream\n *\n * __Signature__: `(...Stream * -> Stream b -> b) -> [Stream *] -> Stream b`\n *\n * @name flyd.combine\n * @param {Function} fn - the function used to combine the streams\n * @param {Array<stream>} dependencies - the streams that this one depends on\n * @return {stream} the dependent stream\n *\n * @example\n * var n1 = flyd.stream(0);\n * var n2 = flyd.stream(0);\n * var max = flyd.combine(function(n1, n2, self, changed) {\n *   return n1() > n2() ? n1() : n2();\n * }, [n1, n2]);\n */\nflyd.combine = curryN(2, combine);\nfunction combine(fn, streams) {\n  var i, s, deps, depEndStreams;\n  var endStream = createDependentStream([], trueFn);\n  deps = []; depEndStreams = [];\n  for (i = 0; i < streams.length; ++i) {\n    if (streams[i] !== undefined) {\n      deps.push(streams[i]);\n      if (streams[i].end !== undefined) depEndStreams.push(streams[i].end);\n    }\n  }\n  s = createDependentStream(deps, fn);\n  s.depsChanged = [];\n  s.fnArgs = s.deps.concat([s, s.depsChanged]);\n  s.end = endStream;\n  endStream.listeners.push(s);\n  addListeners(depEndStreams, endStream);\n  endStream.deps = depEndStreams;\n  updateStream(s);\n  return s;\n}\n\n/**\n * Returns `true` if the supplied argument is a Flyd stream and `false` otherwise.\n *\n * __Signature__: `* -> Boolean`\n *\n * @name flyd.isStream\n * @param {*} value - the value to test\n * @return {Boolean} `true` if is a Flyd streamn, `false` otherwise\n *\n * @example\n * var s = flyd.stream(1);\n * var n = 1;\n * flyd.isStream(s); //=> true\n * flyd.isStream(n); //=> false\n */\nflyd.isStream = function(stream) {\n  return isFunction(stream) && 'hasVal' in stream;\n}\n\n/**\n * Invokes the body (the function to calculate the value) of a dependent stream\n *\n * By default the body of a dependent stream is only called when all the streams\n * upon which it depends has a value. `immediate` can circumvent this behaviour.\n * It immediately invokes the body of a dependent stream.\n *\n * __Signature__: `Stream a -> Stream a`\n *\n * @name flyd.immediate\n * @param {stream} stream - the dependent stream\n * @return {stream} the same stream\n *\n * @example\n * var s = flyd.stream();\n * var hasItems = flyd.immediate(flyd.combine(function(s) {\n *   return s() !== undefined && s().length > 0;\n * }, [s]);\n * console.log(hasItems()); // logs `false`. Had `immediate` not been\n *                          // used `hasItems()` would've returned `undefined`\n * s([1]);\n * console.log(hasItems()); // logs `true`.\n * s([]);\n * console.log(hasItems()); // logs `false`.\n */\nflyd.immediate = function(s) {\n  if (s.depsMet === false) {\n    s.depsMet = true;\n    updateStream(s);\n  }\n  return s;\n}\n\n/**\n * Changes which `endsStream` should trigger the ending of `s`.\n *\n * __Signature__: `Stream a -> Stream b -> Stream b`\n *\n * @name flyd.endsOn\n * @param {stream} endStream - the stream to trigger the ending\n * @param {stream} stream - the stream to be ended by the endStream\n * @param {stream} the stream modified to be ended by endStream\n *\n * @example\n * var n = flyd.stream(1);\n * var killer = flyd.stream();\n * // `double` ends when `n` ends or when `killer` emits any value\n * var double = flyd.endsOn(flyd.merge(n.end, killer), flyd.combine(function(n) {\n *   return 2 * n();\n * }, [n]);\n*/\nflyd.endsOn = function(endS, s) {\n  detachDeps(s.end);\n  endS.listeners.push(s.end);\n  s.end.deps.push(endS);\n  return s;\n}\n\n/**\n * Map a stream\n *\n * Returns a new stream consisting of every value from `s` passed through\n * `fn`. I.e. `map` creates a new stream that listens to `s` and\n * applies `fn` to every new value.\n * __Signature__: `(a -> result) -> Stream a -> Stream result`\n *\n * @name flyd.map\n * @param {Function} fn - the function that produces the elements of the new stream\n * @param {stream} stream - the stream to map\n * @return {stream} a new stream with the mapped values\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = flyd.map(function(n) { return n*n; }, numbers);\n */\n// Library functions use self callback to accept (null, undefined) update triggers.\nflyd.map = curryN(2, function(f, s) {\n  return combine(function(s, self) { self(f(s.val)); }, [s]);\n})\n\n/**\n * Listen to stream events\n *\n * Similar to `map` except that the returned stream is empty. Use `on` for doing\n * side effects in reaction to stream changes. Use the returned stream only if you\n * need to manually end it.\n *\n * __Signature__: `(a -> result) -> Stream a -> Stream undefined`\n *\n * @name flyd.on\n * @param {Function} cb - the callback\n * @param {stream} stream - the stream\n * @return {stream} an empty stream (can be ended)\n */\nflyd.on = curryN(2, function(f, s) {\n  return combine(function(s) { f(s.val); }, [s]);\n})\n\n/**\n * Creates a new stream with the results of calling the function on every incoming\n * stream with and accumulator and the incoming value.\n *\n * __Signature__: `(a -> b -> a) -> a -> Stream b -> Stream a`\n *\n * @name flyd.scan\n * @param {Function} fn - the function to call\n * @param {*} val - the initial value of the accumulator\n * @param {stream} stream - the stream source\n * @return {stream} the new stream\n *\n * @example\n * var numbers = flyd.stream();\n * var sum = flyd.scan(function(sum, n) { return sum+n; }, 0, numbers);\n * numbers(2)(3)(5);\n * sum(); // 10\n */\nflyd.scan = curryN(3, function(f, acc, s) {\n  var ns = combine(function(s, self) {\n    self(acc = f(acc, s.val));\n  }, [s]);\n  if (!ns.hasVal) ns(acc);\n  return ns;\n});\n\n/**\n * Creates a new stream down which all values from both `stream1` and `stream2`\n * will be sent.\n *\n * __Signature__: `Stream a -> Stream a -> Stream a`\n *\n * @name flyd.merge\n * @param {stream} source1 - one stream to be merged\n * @param {stream} source2 - the other stream to be merged\n * @return {stream} a stream with the values from both sources\n *\n * @example\n * var btn1Clicks = flyd.stream();\n * button1Elm.addEventListener(btn1Clicks);\n * var btn2Clicks = flyd.stream();\n * button2Elm.addEventListener(btn2Clicks);\n * var allClicks = flyd.merge(btn1Clicks, btn2Clicks);\n */\nflyd.merge = curryN(2, function(s1, s2) {\n  var s = flyd.immediate(combine(function(s1, s2, self, changed) {\n    if (changed[0]) {\n      self(changed[0]());\n    } else if (s1.hasVal) {\n      self(s1.val);\n    } else if (s2.hasVal) {\n      self(s2.val);\n    }\n  }, [s1, s2]));\n  flyd.endsOn(combine(function() {\n    return true;\n  }, [s1.end, s2.end]), s);\n  return s;\n});\n\n/**\n * Creates a new stream resulting from applying `transducer` to `stream`.\n *\n * __Signature__: `Transducer -> Stream a -> Stream b`\n *\n * @name flyd.transduce\n * @param {Transducer} xform - the transducer transformation\n * @param {stream} source - the stream source\n * @return {stream} the new stream\n *\n * @example\n * var t = require('transducers.js');\n *\n * var results = [];\n * var s1 = flyd.stream();\n * var tx = t.compose(t.map(function(x) { return x * 2; }), t.dedupe());\n * var s2 = flyd.transduce(tx, s1);\n * flyd.combine(function(s2) { results.push(s2()); }, [s2]);\n * s1(1)(1)(2)(3)(3)(3)(4);\n * results; // => [2, 4, 6, 8]\n */\nflyd.transduce = curryN(2, function(xform, source) {\n  xform = xform(new StreamTransformer());\n  return combine(function(source, self) {\n    var res = xform['@@transducer/step'](undefined, source.val);\n    if (res && res['@@transducer/reduced'] === true) {\n      self.end(true);\n      return res['@@transducer/value'];\n    } else {\n      return res;\n    }\n  }, [source]);\n});\n\n/**\n * Returns `fn` curried to `n`. Use this function to curry functions exposed by\n * modules for Flyd.\n *\n * @name flyd.curryN\n * @function\n * @param {Integer} arity - the function arity\n * @param {Function} fn - the function to curry\n * @return {Function} the curried function\n *\n * @example\n * function add(x, y) { return x + y; };\n * var a = flyd.curryN(2, add);\n * a(2)(4) // => 6\n */\nflyd.curryN = curryN\n\n/**\n * Returns a new stream identical to the original except every\n * value will be passed through `f`.\n *\n * _Note:_ This function is included in order to support the fantasy land\n * specification.\n *\n * __Signature__: Called bound to `Stream a`: `(a -> b) -> Stream b`\n *\n * @name stream.map\n * @param {Function} function - the function to apply\n * @return {stream} a new stream with the values mapped\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = numbers.map(function(n) { return n*n; });\n */\nfunction boundMap(f) { return flyd.map(f, this); }\n\n/**\n * Returns a new stream which is the result of applying the\n * functions from `this` stream to the values in `stream` parameter.\n *\n * `this` stream must be a stream of functions.\n *\n * _Note:_ This function is included in order to support the fantasy land\n * specification.\n *\n * __Signature__: Called bound to `Stream (a -> b)`: `a -> Stream b`\n *\n * @name stream.ap\n * @param {stream} stream - the values stream\n * @return {stream} a new stream with the functions applied to values\n *\n * @example\n * var add = flyd.curryN(2, function(x, y) { return x + y; });\n * var numbers1 = flyd.stream();\n * var numbers2 = flyd.stream();\n * var addToNumbers1 = flyd.map(add, numbers1);\n * var added = addToNumbers1.ap(numbers2);\n */\nfunction ap(s2) {\n  var s1 = this;\n  return combine(function(s1, s2, self) { self(s1.val(s2.val)); }, [s1, s2]);\n}\n\n/**\n * Get a human readable view of a stream\n * @name stream.toString\n * @return {String} the stream string representation\n */\nfunction streamToString() {\n  return 'stream(' + this.val + ')';\n}\n\n/**\n * @name stream.end\n * @memberof stream\n * A stream that emits `true` when the stream ends. If `true` is pushed down the\n * stream the parent stream ends.\n */\n\n/**\n * @name stream.of\n * @function\n * @memberof stream\n * Returns a new stream with `value` as its initial value. It is identical to\n * calling `flyd.stream` with one argument.\n *\n * __Signature__: Called bound to `Stream (a)`: `b -> Stream b`\n *\n * @param {*} value - the initial value\n * @return {stream} the new stream\n *\n * @example\n * var n = flyd.stream(1);\n * var m = n.of(1);\n */\n\n// /////////////////////////// PRIVATE ///////////////////////////////// //\n/**\n * @private\n * Create a stream with no dependencies and no value\n * @return {Function} a flyd stream\n */\nfunction createStream() {\n  function s(n) {\n    if (arguments.length === 0) return s.val\n    updateStreamValue(s, n)\n    return s\n  }\n  s.hasVal = false;\n  s.val = undefined;\n  s.vals = [];\n  s.listeners = [];\n  s.queued = false;\n  s.end = undefined;\n  s.map = boundMap;\n  s.ap = ap;\n  s.of = flyd.stream;\n  s.toString = streamToString;\n  return s;\n}\n\n/**\n * @private\n * Create a dependent stream\n * @param {Array<stream>} dependencies - an array of the streams\n * @param {Function} fn - the function used to calculate the new stream value\n * from the dependencies\n * @return {stream} the created stream\n */\nfunction createDependentStream(deps, fn) {\n  var s = createStream();\n  s.fn = fn;\n  s.deps = deps;\n  s.depsMet = false;\n  s.depsChanged = deps.length > 0 ? [] : undefined;\n  s.shouldUpdate = false;\n  addListeners(deps, s);\n  return s;\n}\n\n/**\n * @private\n * Check if all the dependencies have values\n * @param {stream} stream - the stream to check depencencies from\n * @return {Boolean} `true` if all dependencies have vales, `false` otherwise\n */\nfunction initialDepsNotMet(stream) {\n  stream.depsMet = stream.deps.every(function(s) {\n    return s.hasVal;\n  });\n  return !stream.depsMet;\n}\n\n/**\n * @private\n * Update a dependent stream using its dependencies in an atomic way\n * @param {stream} stream - the stream to update\n */\nfunction updateStream(s) {\n  if ((s.depsMet !== true && initialDepsNotMet(s)) ||\n      (s.end !== undefined && s.end.val === true)) return;\n  if (inStream !== undefined) {\n    toUpdate.push(s);\n    return;\n  }\n  inStream = s;\n  if (s.depsChanged) s.fnArgs[s.fnArgs.length - 1] = s.depsChanged;\n  var returnVal = s.fn.apply(s.fn, s.fnArgs);\n  if (returnVal !== undefined) {\n    s(returnVal);\n  }\n  inStream = undefined;\n  if (s.depsChanged !== undefined) s.depsChanged = [];\n  s.shouldUpdate = false;\n  if (flushing === false) flushUpdate();\n}\n\n/**\n * @private\n * Update the dependencies of a stream\n * @param {stream} stream\n */\nfunction updateDeps(s) {\n  var i, o, list\n  var listeners = s.listeners;\n  for (i = 0; i < listeners.length; ++i) {\n    list = listeners[i];\n    if (list.end === s) {\n      endStream(list);\n    } else {\n      if (list.depsChanged !== undefined) list.depsChanged.push(s);\n      list.shouldUpdate = true;\n      findDeps(list);\n    }\n  }\n  for (; orderNextIdx >= 0; --orderNextIdx) {\n    o = order[orderNextIdx];\n    if (o.shouldUpdate === true) updateStream(o);\n    o.queued = false;\n  }\n}\n\n/**\n * @private\n * Add stream dependencies to the global `order` queue.\n * @param {stream} stream\n * @see updateDeps\n */\nfunction findDeps(s) {\n  var i\n  var listeners = s.listeners;\n  if (s.queued === false) {\n    s.queued = true;\n    for (i = 0; i < listeners.length; ++i) {\n      findDeps(listeners[i]);\n    }\n    order[++orderNextIdx] = s;\n  }\n}\n\n/**\n * @private\n */\nfunction flushUpdate() {\n  flushing = true;\n  while (toUpdate.length > 0) {\n    var s = toUpdate.shift();\n    if (s.vals.length > 0) s.val = s.vals.shift();\n    updateDeps(s);\n  }\n  flushing = false;\n}\n\n/**\n * @private\n * Push down a value into a stream\n * @param {stream} stream\n * @param {*} value\n */\nfunction updateStreamValue(s, n) {\n  if (n !== undefined && n !== null && isFunction(n.then)) {\n    n.then(s);\n    return;\n  }\n  s.val = n;\n  s.hasVal = true;\n  if (inStream === undefined) {\n    flushing = true;\n    updateDeps(s);\n    if (toUpdate.length > 0) flushUpdate(); else flushing = false;\n  } else if (inStream === s) {\n    markListeners(s, s.listeners);\n  } else {\n    s.vals.push(n);\n    toUpdate.push(s);\n  }\n}\n\n/**\n * @private\n */\nfunction markListeners(s, lists) {\n  var i, list;\n  for (i = 0; i < lists.length; ++i) {\n    list = lists[i];\n    if (list.end !== s) {\n      if (list.depsChanged !== undefined) {\n        list.depsChanged.push(s);\n      }\n      list.shouldUpdate = true;\n    } else {\n      endStream(list);\n    }\n  }\n}\n\n/**\n * @private\n * Add dependencies to a stream\n * @param {Array<stream>} dependencies\n * @param {stream} stream\n */\nfunction addListeners(deps, s) {\n  for (var i = 0; i < deps.length; ++i) {\n    deps[i].listeners.push(s);\n  }\n}\n\n/**\n * @private\n * Removes an stream from a dependency array\n * @param {stream} stream\n * @param {Array<stream>} dependencies\n */\nfunction removeListener(s, listeners) {\n  var idx = listeners.indexOf(s);\n  listeners[idx] = listeners[listeners.length - 1];\n  listeners.length--;\n}\n\n/**\n * @private\n * Detach a stream from its dependencies\n * @param {stream} stream\n */\nfunction detachDeps(s) {\n  for (var i = 0; i < s.deps.length; ++i) {\n    removeListener(s, s.deps[i].listeners);\n  }\n  s.deps.length = 0;\n}\n\n/**\n * @private\n * Ends a stream\n */\nfunction endStream(s) {\n  if (s.deps !== undefined) detachDeps(s);\n  if (s.end !== undefined) detachDeps(s.end);\n}\n\n/**\n * @private\n * transducer stream transformer\n */\nfunction StreamTransformer() { }\nStreamTransformer.prototype['@@transducer/init'] = function() { };\nStreamTransformer.prototype['@@transducer/result'] = function() { };\nStreamTransformer.prototype['@@transducer/step'] = function(s, v) { return v; };\n\nmodule.exports = flyd;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _arity = __webpack_require__(1);\nvar _curry1 = __webpack_require__(2);\nvar _curry2 = __webpack_require__(6);\nvar _curryN = __webpack_require__(7);\n\n\n/**\n * Returns a curried equivalent of the provided function, with the specified\n * arity. The curried function has two unusual capabilities. First, its\n * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n * following are equivalent:\n *\n *   - `g(1)(2)(3)`\n *   - `g(1)(2, 3)`\n *   - `g(1, 2)(3)`\n *   - `g(1, 2, 3)`\n *\n * Secondly, the special placeholder value `R.__` may be used to specify\n * \"gaps\", allowing partial application of any combination of arguments,\n * regardless of their positions. If `g` is as above and `_` is `R.__`, the\n * following are equivalent:\n *\n *   - `g(1, 2, 3)`\n *   - `g(_, 2, 3)(1)`\n *   - `g(_, _, 3)(1)(2)`\n *   - `g(_, _, 3)(1, 2)`\n *   - `g(_, 2)(1)(3)`\n *   - `g(_, 2)(1, 3)`\n *   - `g(_, 2)(_, 3)(1)`\n *\n * @func\n * @memberOf R\n * @since v0.5.0\n * @category Function\n * @sig Number -> (* -> a) -> (* -> a)\n * @param {Number} length The arity for the returned function.\n * @param {Function} fn The function to curry.\n * @return {Function} A new, curried function.\n * @see R.curry\n * @example\n *\n *      var sumArgs = (...args) => R.sum(args);\n *\n *      var curriedAddFourNumbers = R.curryN(4, sumArgs);\n *      var f = curriedAddFourNumbers(1, 2);\n *      var g = f(3);\n *      g(4); //=> 10\n */\nmodule.exports = _curry2(function curryN(length, fn) {\n  if (length === 1) {\n    return _curry1(fn);\n  }\n  return _arity(length, _curryN(length, [], fn));\n});\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _curry1 = __webpack_require__(2);\nvar _isPlaceholder = __webpack_require__(0);\n\n\n/**\n * Optimized internal two-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curry2(fn) {\n  return function f2(a, b) {\n    switch (arguments.length) {\n      case 0:\n        return f2;\n      case 1:\n        return _isPlaceholder(a) ? f2\n             : _curry1(function(_b) { return fn(a, _b); });\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b) ? f2\n             : _isPlaceholder(a) ? _curry1(function(_a) { return fn(_a, b); })\n             : _isPlaceholder(b) ? _curry1(function(_b) { return fn(a, _b); })\n             : fn(a, b);\n    }\n  };\n};\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _arity = __webpack_require__(1);\nvar _isPlaceholder = __webpack_require__(0);\n\n\n/**\n * Internal curryN function.\n *\n * @private\n * @category Function\n * @param {Number} length The arity of the curried function.\n * @param {Array} received An array of arguments received thus far.\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curryN(length, received, fn) {\n  return function() {\n    var combined = [];\n    var argsIdx = 0;\n    var left = length;\n    var combinedIdx = 0;\n    while (combinedIdx < received.length || argsIdx < arguments.length) {\n      var result;\n      if (combinedIdx < received.length &&\n          (!_isPlaceholder(received[combinedIdx]) ||\n           argsIdx >= arguments.length)) {\n        result = received[combinedIdx];\n      } else {\n        result = arguments[argsIdx];\n        argsIdx += 1;\n      }\n      combined[combinedIdx] = result;\n      if (!_isPlaceholder(result)) {\n        left -= 1;\n      }\n      combinedIdx += 1;\n    }\n    return left <= 0 ? fn.apply(this, combined)\n                     : _arity(left, _curryN(length, combined, fn));\n  };\n};\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(__webpack_require__(3));\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// meiosis.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 91984feeba07e07e1b98","module.exports = function _isPlaceholder(a) {\n  return a != null &&\n         typeof a === 'object' &&\n         a['@@functional/placeholder'] === true;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/internal/_isPlaceholder.js\n// module id = 0\n// module chunks = 0","module.exports = function _arity(n, fn) {\n  /* eslint-disable no-unused-vars */\n  switch (n) {\n    case 0: return function() { return fn.apply(this, arguments); };\n    case 1: return function(a0) { return fn.apply(this, arguments); };\n    case 2: return function(a0, a1) { return fn.apply(this, arguments); };\n    case 3: return function(a0, a1, a2) { return fn.apply(this, arguments); };\n    case 4: return function(a0, a1, a2, a3) { return fn.apply(this, arguments); };\n    case 5: return function(a0, a1, a2, a3, a4) { return fn.apply(this, arguments); };\n    case 6: return function(a0, a1, a2, a3, a4, a5) { return fn.apply(this, arguments); };\n    case 7: return function(a0, a1, a2, a3, a4, a5, a6) { return fn.apply(this, arguments); };\n    case 8: return function(a0, a1, a2, a3, a4, a5, a6, a7) { return fn.apply(this, arguments); };\n    case 9: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) { return fn.apply(this, arguments); };\n    case 10: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) { return fn.apply(this, arguments); };\n    default: throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/internal/_arity.js\n// module id = 1\n// module chunks = 0","var _isPlaceholder = require('./_isPlaceholder');\n\n\n/**\n * Optimized internal one-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curry1(fn) {\n  return function f1(a) {\n    if (arguments.length === 0 || _isPlaceholder(a)) {\n      return f1;\n    } else {\n      return fn.apply(this, arguments);\n    }\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/internal/_curry1.js\n// module id = 2\n// module chunks = 0","/// <reference path=\"../lib/flyd.d.ts\" />\n\nimport * as flyd from \"flyd\";\n\nexport type Stream<T> = Flyd.Stream<T>;\nexport type Scanner<A, B> = Flyd.Scanner<A, B>;\nexport type Mapper<A, B> = Flyd.Mapper<A, B>;\n\nexport interface MapperSpec<A, B> {\n  [name: string]: Mapper<A, B>;\n}\n\nexport interface ModelChange<M> {\n  (model: M): M;\n}\n\nexport interface NextAction {\n  (model: any): void;\n}\n\nexport interface RunParameters<M> {\n  initialModel: M;\n  modelChanges: Stream<ModelChange<M>>;\n  mappers?: Array<MapperSpec<any, any> | Mapper<any, any>>;\n  nextAction?: NextAction;\n  copy?: any;//FIXME\n}\n\nexport interface MeiosisRun<M> {\n  (params: RunParameters<M>): MeiosisApp;\n}\n\nexport interface MeiosisInstance<M> {\n  run: MeiosisRun<M>;\n}\n\nexport interface MeiosisApp {\n  [key: string]: Stream<any>;\n}\n\ninterface NamedStream {\n  name: string;\n  stream: Stream<any>;\n}\n\ninterface NamedValue {\n  name: string;\n  value: any;\n}\n\nexport const {\n  combine,\n  map,\n  merge,\n  on,\n  scan,\n  stream\n} = flyd;\n\nexport const mergeAll = (streams: Array<Stream<any>>) => {\n  const merged = stream();\n  streams.forEach(s => map(merged, s));\n  return merged;\n};\n\nconst getName = (value: any) => typeof value === \"function\" ? undefined : Object.keys(value)[0];\nconst getFn = (value: any) => {\n  const name = getName(value);\n  return name ? value[name] : value;\n};\n\nfunction newInstance<M>(): MeiosisInstance<M> {\n  const run = (params: RunParameters<M>): MeiosisApp => {\n    if (!params.initialModel || !params.modelChanges) {\n      throw new Error(\"Please specify initialModel and modelChanges.\");\n    }\n    const streams: MeiosisApp = {};\n    const allStreams: Array<NamedStream> = [];\n\n    let lastStream: Stream<M> = scan((model: M, modelChange: ModelChange<M>) => modelChange(model),\n      params.initialModel, params.modelChanges);\n\n    const scannerStream = lastStream;\n    const scannerName = \"modelChanges\";\n    streams[scannerName] = lastStream;\n    allStreams.push({ name: scannerName, stream: lastStream });\n\n    (params.mappers || []).forEach(mapper => {\n      const mapperName: string = getName(mapper);\n      const mapperFn: Mapper<any, any> = getFn(mapper);\n\n      lastStream = map(mapperFn, lastStream);\n      mapperName && (streams[mapperName] = lastStream);\n      allStreams.push({ name: (mapperName || \"\"), stream: lastStream });\n    });\n\n    const render: Stream<any> = stream();\n\n    /*\n    if (params.nextAction) {\n      let lastProposal: P = propose();\n\n      on((value: any) => {\n        const proposal: P = propose();\n\n        render(value);\n        if (proposal !== lastProposal) {\n          params.nextAction(value, proposal);\n        }\n        lastProposal = proposal;\n      }, lastStream);\n    }\n    else {\n    */\n      on(render, lastStream);\n    //}\n\n    streams[\"render\"] = render;\n\n    const devtool: boolean = window && window[\"__MEIOSIS_TRACER_GLOBAL_HOOK__\"];\n    if (devtool) {\n      const copy: any = params.copy || ((model: M) => JSON.parse(JSON.stringify(model)));\n      const bufferedValues: Array<any> = [];\n      let devtoolInitialized: boolean = false;\n      const sendValues: Stream<boolean> = stream(true);\n\n      let changes: Stream<Date> = stream(new Date());\n      let lastChange: Date = changes();\n      on(() => changes(new Date()), params.modelChanges);\n\n      window.addEventListener(\"message\", evt => {\n        if (evt.data.type === \"MEIOSIS_RENDER_MODEL\") {\n          sendValues(evt.data.sendValuesBack);\n          scannerStream(evt.data.model);\n        }\n        else if (evt.data.type === \"MEIOSIS_TRACER_INIT\") {\n          devtoolInitialized = true;\n          bufferedValues.forEach(values => window.postMessage({ type: \"MEIOSIS_VALUES\", values }, \"*\"));\n        }\n      });\n\n      on(() => {\n        const change: Date = changes();\n        const update: boolean = change !== lastChange;\n        lastChange = change;\n\n        const values: Array<NamedValue> = allStreams.map((namedStream: NamedStream) =>\n          ({ name: namedStream.name, value: copy(namedStream.stream()) }));\n\n        if (sendValues()) {\n          if (devtoolInitialized) {\n            window.postMessage({ type: \"MEIOSIS_VALUES\", values, update }, \"*\");\n          }\n          else {\n            bufferedValues.push(values);\n          }\n        }\n      }, lastStream);\n    }\n\n    return streams;\n  };\n\n  return {\n    run\n  };\n}\n\nconst instance = newInstance<any>();\nconst run = instance.run;\n\nexport {\n  newInstance,\n  run\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/meiosis.ts","'use strict';\n\nvar curryN = require('ramda/src/curryN');\n\n// Utility\nfunction isFunction(obj) {\n  return !!(obj && obj.constructor && obj.call && obj.apply);\n}\nfunction trueFn() { return true; }\n\n// Globals\nvar toUpdate = [];\nvar inStream;\nvar order = [];\nvar orderNextIdx = -1;\nvar flushing = false;\n\n/** @namespace */\nvar flyd = {}\n\n// /////////////////////////// API ///////////////////////////////// //\n\n/**\n * Creates a new stream\n *\n * __Signature__: `a -> Stream a`\n *\n * @name flyd.stream\n * @param {*} initialValue - (Optional) the initial value of the stream\n * @return {stream} the stream\n *\n * @example\n * var n = flyd.stream(1); // Stream with initial value `1`\n * var s = flyd.stream(); // Stream with no initial value\n */\nflyd.stream = function(initialValue) {\n  var endStream = createDependentStream([], trueFn);\n  var s = createStream();\n  s.end = endStream;\n  s.fnArgs = [];\n  endStream.listeners.push(s);\n  s.toJSON = function() {\n    return s();\n  };\n  if (arguments.length > 0) s(initialValue);\n  return s;\n}\n\n/**\n * Create a new dependent stream\n *\n * __Signature__: `(...Stream * -> Stream b -> b) -> [Stream *] -> Stream b`\n *\n * @name flyd.combine\n * @param {Function} fn - the function used to combine the streams\n * @param {Array<stream>} dependencies - the streams that this one depends on\n * @return {stream} the dependent stream\n *\n * @example\n * var n1 = flyd.stream(0);\n * var n2 = flyd.stream(0);\n * var max = flyd.combine(function(n1, n2, self, changed) {\n *   return n1() > n2() ? n1() : n2();\n * }, [n1, n2]);\n */\nflyd.combine = curryN(2, combine);\nfunction combine(fn, streams) {\n  var i, s, deps, depEndStreams;\n  var endStream = createDependentStream([], trueFn);\n  deps = []; depEndStreams = [];\n  for (i = 0; i < streams.length; ++i) {\n    if (streams[i] !== undefined) {\n      deps.push(streams[i]);\n      if (streams[i].end !== undefined) depEndStreams.push(streams[i].end);\n    }\n  }\n  s = createDependentStream(deps, fn);\n  s.depsChanged = [];\n  s.fnArgs = s.deps.concat([s, s.depsChanged]);\n  s.end = endStream;\n  endStream.listeners.push(s);\n  addListeners(depEndStreams, endStream);\n  endStream.deps = depEndStreams;\n  updateStream(s);\n  return s;\n}\n\n/**\n * Returns `true` if the supplied argument is a Flyd stream and `false` otherwise.\n *\n * __Signature__: `* -> Boolean`\n *\n * @name flyd.isStream\n * @param {*} value - the value to test\n * @return {Boolean} `true` if is a Flyd streamn, `false` otherwise\n *\n * @example\n * var s = flyd.stream(1);\n * var n = 1;\n * flyd.isStream(s); //=> true\n * flyd.isStream(n); //=> false\n */\nflyd.isStream = function(stream) {\n  return isFunction(stream) && 'hasVal' in stream;\n}\n\n/**\n * Invokes the body (the function to calculate the value) of a dependent stream\n *\n * By default the body of a dependent stream is only called when all the streams\n * upon which it depends has a value. `immediate` can circumvent this behaviour.\n * It immediately invokes the body of a dependent stream.\n *\n * __Signature__: `Stream a -> Stream a`\n *\n * @name flyd.immediate\n * @param {stream} stream - the dependent stream\n * @return {stream} the same stream\n *\n * @example\n * var s = flyd.stream();\n * var hasItems = flyd.immediate(flyd.combine(function(s) {\n *   return s() !== undefined && s().length > 0;\n * }, [s]);\n * console.log(hasItems()); // logs `false`. Had `immediate` not been\n *                          // used `hasItems()` would've returned `undefined`\n * s([1]);\n * console.log(hasItems()); // logs `true`.\n * s([]);\n * console.log(hasItems()); // logs `false`.\n */\nflyd.immediate = function(s) {\n  if (s.depsMet === false) {\n    s.depsMet = true;\n    updateStream(s);\n  }\n  return s;\n}\n\n/**\n * Changes which `endsStream` should trigger the ending of `s`.\n *\n * __Signature__: `Stream a -> Stream b -> Stream b`\n *\n * @name flyd.endsOn\n * @param {stream} endStream - the stream to trigger the ending\n * @param {stream} stream - the stream to be ended by the endStream\n * @param {stream} the stream modified to be ended by endStream\n *\n * @example\n * var n = flyd.stream(1);\n * var killer = flyd.stream();\n * // `double` ends when `n` ends or when `killer` emits any value\n * var double = flyd.endsOn(flyd.merge(n.end, killer), flyd.combine(function(n) {\n *   return 2 * n();\n * }, [n]);\n*/\nflyd.endsOn = function(endS, s) {\n  detachDeps(s.end);\n  endS.listeners.push(s.end);\n  s.end.deps.push(endS);\n  return s;\n}\n\n/**\n * Map a stream\n *\n * Returns a new stream consisting of every value from `s` passed through\n * `fn`. I.e. `map` creates a new stream that listens to `s` and\n * applies `fn` to every new value.\n * __Signature__: `(a -> result) -> Stream a -> Stream result`\n *\n * @name flyd.map\n * @param {Function} fn - the function that produces the elements of the new stream\n * @param {stream} stream - the stream to map\n * @return {stream} a new stream with the mapped values\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = flyd.map(function(n) { return n*n; }, numbers);\n */\n// Library functions use self callback to accept (null, undefined) update triggers.\nflyd.map = curryN(2, function(f, s) {\n  return combine(function(s, self) { self(f(s.val)); }, [s]);\n})\n\n/**\n * Listen to stream events\n *\n * Similar to `map` except that the returned stream is empty. Use `on` for doing\n * side effects in reaction to stream changes. Use the returned stream only if you\n * need to manually end it.\n *\n * __Signature__: `(a -> result) -> Stream a -> Stream undefined`\n *\n * @name flyd.on\n * @param {Function} cb - the callback\n * @param {stream} stream - the stream\n * @return {stream} an empty stream (can be ended)\n */\nflyd.on = curryN(2, function(f, s) {\n  return combine(function(s) { f(s.val); }, [s]);\n})\n\n/**\n * Creates a new stream with the results of calling the function on every incoming\n * stream with and accumulator and the incoming value.\n *\n * __Signature__: `(a -> b -> a) -> a -> Stream b -> Stream a`\n *\n * @name flyd.scan\n * @param {Function} fn - the function to call\n * @param {*} val - the initial value of the accumulator\n * @param {stream} stream - the stream source\n * @return {stream} the new stream\n *\n * @example\n * var numbers = flyd.stream();\n * var sum = flyd.scan(function(sum, n) { return sum+n; }, 0, numbers);\n * numbers(2)(3)(5);\n * sum(); // 10\n */\nflyd.scan = curryN(3, function(f, acc, s) {\n  var ns = combine(function(s, self) {\n    self(acc = f(acc, s.val));\n  }, [s]);\n  if (!ns.hasVal) ns(acc);\n  return ns;\n});\n\n/**\n * Creates a new stream down which all values from both `stream1` and `stream2`\n * will be sent.\n *\n * __Signature__: `Stream a -> Stream a -> Stream a`\n *\n * @name flyd.merge\n * @param {stream} source1 - one stream to be merged\n * @param {stream} source2 - the other stream to be merged\n * @return {stream} a stream with the values from both sources\n *\n * @example\n * var btn1Clicks = flyd.stream();\n * button1Elm.addEventListener(btn1Clicks);\n * var btn2Clicks = flyd.stream();\n * button2Elm.addEventListener(btn2Clicks);\n * var allClicks = flyd.merge(btn1Clicks, btn2Clicks);\n */\nflyd.merge = curryN(2, function(s1, s2) {\n  var s = flyd.immediate(combine(function(s1, s2, self, changed) {\n    if (changed[0]) {\n      self(changed[0]());\n    } else if (s1.hasVal) {\n      self(s1.val);\n    } else if (s2.hasVal) {\n      self(s2.val);\n    }\n  }, [s1, s2]));\n  flyd.endsOn(combine(function() {\n    return true;\n  }, [s1.end, s2.end]), s);\n  return s;\n});\n\n/**\n * Creates a new stream resulting from applying `transducer` to `stream`.\n *\n * __Signature__: `Transducer -> Stream a -> Stream b`\n *\n * @name flyd.transduce\n * @param {Transducer} xform - the transducer transformation\n * @param {stream} source - the stream source\n * @return {stream} the new stream\n *\n * @example\n * var t = require('transducers.js');\n *\n * var results = [];\n * var s1 = flyd.stream();\n * var tx = t.compose(t.map(function(x) { return x * 2; }), t.dedupe());\n * var s2 = flyd.transduce(tx, s1);\n * flyd.combine(function(s2) { results.push(s2()); }, [s2]);\n * s1(1)(1)(2)(3)(3)(3)(4);\n * results; // => [2, 4, 6, 8]\n */\nflyd.transduce = curryN(2, function(xform, source) {\n  xform = xform(new StreamTransformer());\n  return combine(function(source, self) {\n    var res = xform['@@transducer/step'](undefined, source.val);\n    if (res && res['@@transducer/reduced'] === true) {\n      self.end(true);\n      return res['@@transducer/value'];\n    } else {\n      return res;\n    }\n  }, [source]);\n});\n\n/**\n * Returns `fn` curried to `n`. Use this function to curry functions exposed by\n * modules for Flyd.\n *\n * @name flyd.curryN\n * @function\n * @param {Integer} arity - the function arity\n * @param {Function} fn - the function to curry\n * @return {Function} the curried function\n *\n * @example\n * function add(x, y) { return x + y; };\n * var a = flyd.curryN(2, add);\n * a(2)(4) // => 6\n */\nflyd.curryN = curryN\n\n/**\n * Returns a new stream identical to the original except every\n * value will be passed through `f`.\n *\n * _Note:_ This function is included in order to support the fantasy land\n * specification.\n *\n * __Signature__: Called bound to `Stream a`: `(a -> b) -> Stream b`\n *\n * @name stream.map\n * @param {Function} function - the function to apply\n * @return {stream} a new stream with the values mapped\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = numbers.map(function(n) { return n*n; });\n */\nfunction boundMap(f) { return flyd.map(f, this); }\n\n/**\n * Returns a new stream which is the result of applying the\n * functions from `this` stream to the values in `stream` parameter.\n *\n * `this` stream must be a stream of functions.\n *\n * _Note:_ This function is included in order to support the fantasy land\n * specification.\n *\n * __Signature__: Called bound to `Stream (a -> b)`: `a -> Stream b`\n *\n * @name stream.ap\n * @param {stream} stream - the values stream\n * @return {stream} a new stream with the functions applied to values\n *\n * @example\n * var add = flyd.curryN(2, function(x, y) { return x + y; });\n * var numbers1 = flyd.stream();\n * var numbers2 = flyd.stream();\n * var addToNumbers1 = flyd.map(add, numbers1);\n * var added = addToNumbers1.ap(numbers2);\n */\nfunction ap(s2) {\n  var s1 = this;\n  return combine(function(s1, s2, self) { self(s1.val(s2.val)); }, [s1, s2]);\n}\n\n/**\n * Get a human readable view of a stream\n * @name stream.toString\n * @return {String} the stream string representation\n */\nfunction streamToString() {\n  return 'stream(' + this.val + ')';\n}\n\n/**\n * @name stream.end\n * @memberof stream\n * A stream that emits `true` when the stream ends. If `true` is pushed down the\n * stream the parent stream ends.\n */\n\n/**\n * @name stream.of\n * @function\n * @memberof stream\n * Returns a new stream with `value` as its initial value. It is identical to\n * calling `flyd.stream` with one argument.\n *\n * __Signature__: Called bound to `Stream (a)`: `b -> Stream b`\n *\n * @param {*} value - the initial value\n * @return {stream} the new stream\n *\n * @example\n * var n = flyd.stream(1);\n * var m = n.of(1);\n */\n\n// /////////////////////////// PRIVATE ///////////////////////////////// //\n/**\n * @private\n * Create a stream with no dependencies and no value\n * @return {Function} a flyd stream\n */\nfunction createStream() {\n  function s(n) {\n    if (arguments.length === 0) return s.val\n    updateStreamValue(s, n)\n    return s\n  }\n  s.hasVal = false;\n  s.val = undefined;\n  s.vals = [];\n  s.listeners = [];\n  s.queued = false;\n  s.end = undefined;\n  s.map = boundMap;\n  s.ap = ap;\n  s.of = flyd.stream;\n  s.toString = streamToString;\n  return s;\n}\n\n/**\n * @private\n * Create a dependent stream\n * @param {Array<stream>} dependencies - an array of the streams\n * @param {Function} fn - the function used to calculate the new stream value\n * from the dependencies\n * @return {stream} the created stream\n */\nfunction createDependentStream(deps, fn) {\n  var s = createStream();\n  s.fn = fn;\n  s.deps = deps;\n  s.depsMet = false;\n  s.depsChanged = deps.length > 0 ? [] : undefined;\n  s.shouldUpdate = false;\n  addListeners(deps, s);\n  return s;\n}\n\n/**\n * @private\n * Check if all the dependencies have values\n * @param {stream} stream - the stream to check depencencies from\n * @return {Boolean} `true` if all dependencies have vales, `false` otherwise\n */\nfunction initialDepsNotMet(stream) {\n  stream.depsMet = stream.deps.every(function(s) {\n    return s.hasVal;\n  });\n  return !stream.depsMet;\n}\n\n/**\n * @private\n * Update a dependent stream using its dependencies in an atomic way\n * @param {stream} stream - the stream to update\n */\nfunction updateStream(s) {\n  if ((s.depsMet !== true && initialDepsNotMet(s)) ||\n      (s.end !== undefined && s.end.val === true)) return;\n  if (inStream !== undefined) {\n    toUpdate.push(s);\n    return;\n  }\n  inStream = s;\n  if (s.depsChanged) s.fnArgs[s.fnArgs.length - 1] = s.depsChanged;\n  var returnVal = s.fn.apply(s.fn, s.fnArgs);\n  if (returnVal !== undefined) {\n    s(returnVal);\n  }\n  inStream = undefined;\n  if (s.depsChanged !== undefined) s.depsChanged = [];\n  s.shouldUpdate = false;\n  if (flushing === false) flushUpdate();\n}\n\n/**\n * @private\n * Update the dependencies of a stream\n * @param {stream} stream\n */\nfunction updateDeps(s) {\n  var i, o, list\n  var listeners = s.listeners;\n  for (i = 0; i < listeners.length; ++i) {\n    list = listeners[i];\n    if (list.end === s) {\n      endStream(list);\n    } else {\n      if (list.depsChanged !== undefined) list.depsChanged.push(s);\n      list.shouldUpdate = true;\n      findDeps(list);\n    }\n  }\n  for (; orderNextIdx >= 0; --orderNextIdx) {\n    o = order[orderNextIdx];\n    if (o.shouldUpdate === true) updateStream(o);\n    o.queued = false;\n  }\n}\n\n/**\n * @private\n * Add stream dependencies to the global `order` queue.\n * @param {stream} stream\n * @see updateDeps\n */\nfunction findDeps(s) {\n  var i\n  var listeners = s.listeners;\n  if (s.queued === false) {\n    s.queued = true;\n    for (i = 0; i < listeners.length; ++i) {\n      findDeps(listeners[i]);\n    }\n    order[++orderNextIdx] = s;\n  }\n}\n\n/**\n * @private\n */\nfunction flushUpdate() {\n  flushing = true;\n  while (toUpdate.length > 0) {\n    var s = toUpdate.shift();\n    if (s.vals.length > 0) s.val = s.vals.shift();\n    updateDeps(s);\n  }\n  flushing = false;\n}\n\n/**\n * @private\n * Push down a value into a stream\n * @param {stream} stream\n * @param {*} value\n */\nfunction updateStreamValue(s, n) {\n  if (n !== undefined && n !== null && isFunction(n.then)) {\n    n.then(s);\n    return;\n  }\n  s.val = n;\n  s.hasVal = true;\n  if (inStream === undefined) {\n    flushing = true;\n    updateDeps(s);\n    if (toUpdate.length > 0) flushUpdate(); else flushing = false;\n  } else if (inStream === s) {\n    markListeners(s, s.listeners);\n  } else {\n    s.vals.push(n);\n    toUpdate.push(s);\n  }\n}\n\n/**\n * @private\n */\nfunction markListeners(s, lists) {\n  var i, list;\n  for (i = 0; i < lists.length; ++i) {\n    list = lists[i];\n    if (list.end !== s) {\n      if (list.depsChanged !== undefined) {\n        list.depsChanged.push(s);\n      }\n      list.shouldUpdate = true;\n    } else {\n      endStream(list);\n    }\n  }\n}\n\n/**\n * @private\n * Add dependencies to a stream\n * @param {Array<stream>} dependencies\n * @param {stream} stream\n */\nfunction addListeners(deps, s) {\n  for (var i = 0; i < deps.length; ++i) {\n    deps[i].listeners.push(s);\n  }\n}\n\n/**\n * @private\n * Removes an stream from a dependency array\n * @param {stream} stream\n * @param {Array<stream>} dependencies\n */\nfunction removeListener(s, listeners) {\n  var idx = listeners.indexOf(s);\n  listeners[idx] = listeners[listeners.length - 1];\n  listeners.length--;\n}\n\n/**\n * @private\n * Detach a stream from its dependencies\n * @param {stream} stream\n */\nfunction detachDeps(s) {\n  for (var i = 0; i < s.deps.length; ++i) {\n    removeListener(s, s.deps[i].listeners);\n  }\n  s.deps.length = 0;\n}\n\n/**\n * @private\n * Ends a stream\n */\nfunction endStream(s) {\n  if (s.deps !== undefined) detachDeps(s);\n  if (s.end !== undefined) detachDeps(s.end);\n}\n\n/**\n * @private\n * transducer stream transformer\n */\nfunction StreamTransformer() { }\nStreamTransformer.prototype['@@transducer/init'] = function() { };\nStreamTransformer.prototype['@@transducer/result'] = function() { };\nStreamTransformer.prototype['@@transducer/step'] = function(s, v) { return v; };\n\nmodule.exports = flyd;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/flyd/lib/index.js\n// module id = 4\n// module chunks = 0","var _arity = require('./internal/_arity');\nvar _curry1 = require('./internal/_curry1');\nvar _curry2 = require('./internal/_curry2');\nvar _curryN = require('./internal/_curryN');\n\n\n/**\n * Returns a curried equivalent of the provided function, with the specified\n * arity. The curried function has two unusual capabilities. First, its\n * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n * following are equivalent:\n *\n *   - `g(1)(2)(3)`\n *   - `g(1)(2, 3)`\n *   - `g(1, 2)(3)`\n *   - `g(1, 2, 3)`\n *\n * Secondly, the special placeholder value `R.__` may be used to specify\n * \"gaps\", allowing partial application of any combination of arguments,\n * regardless of their positions. If `g` is as above and `_` is `R.__`, the\n * following are equivalent:\n *\n *   - `g(1, 2, 3)`\n *   - `g(_, 2, 3)(1)`\n *   - `g(_, _, 3)(1)(2)`\n *   - `g(_, _, 3)(1, 2)`\n *   - `g(_, 2)(1)(3)`\n *   - `g(_, 2)(1, 3)`\n *   - `g(_, 2)(_, 3)(1)`\n *\n * @func\n * @memberOf R\n * @since v0.5.0\n * @category Function\n * @sig Number -> (* -> a) -> (* -> a)\n * @param {Number} length The arity for the returned function.\n * @param {Function} fn The function to curry.\n * @return {Function} A new, curried function.\n * @see R.curry\n * @example\n *\n *      var sumArgs = (...args) => R.sum(args);\n *\n *      var curriedAddFourNumbers = R.curryN(4, sumArgs);\n *      var f = curriedAddFourNumbers(1, 2);\n *      var g = f(3);\n *      g(4); //=> 10\n */\nmodule.exports = _curry2(function curryN(length, fn) {\n  if (length === 1) {\n    return _curry1(fn);\n  }\n  return _arity(length, _curryN(length, [], fn));\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/curryN.js\n// module id = 5\n// module chunks = 0","var _curry1 = require('./_curry1');\nvar _isPlaceholder = require('./_isPlaceholder');\n\n\n/**\n * Optimized internal two-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curry2(fn) {\n  return function f2(a, b) {\n    switch (arguments.length) {\n      case 0:\n        return f2;\n      case 1:\n        return _isPlaceholder(a) ? f2\n             : _curry1(function(_b) { return fn(a, _b); });\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b) ? f2\n             : _isPlaceholder(a) ? _curry1(function(_a) { return fn(_a, b); })\n             : _isPlaceholder(b) ? _curry1(function(_b) { return fn(a, _b); })\n             : fn(a, b);\n    }\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/internal/_curry2.js\n// module id = 6\n// module chunks = 0","var _arity = require('./_arity');\nvar _isPlaceholder = require('./_isPlaceholder');\n\n\n/**\n * Internal curryN function.\n *\n * @private\n * @category Function\n * @param {Number} length The arity of the curried function.\n * @param {Array} received An array of arguments received thus far.\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curryN(length, received, fn) {\n  return function() {\n    var combined = [];\n    var argsIdx = 0;\n    var left = length;\n    var combinedIdx = 0;\n    while (combinedIdx < received.length || argsIdx < arguments.length) {\n      var result;\n      if (combinedIdx < received.length &&\n          (!_isPlaceholder(received[combinedIdx]) ||\n           argsIdx >= arguments.length)) {\n        result = received[combinedIdx];\n      } else {\n        result = arguments[argsIdx];\n        argsIdx += 1;\n      }\n      combined[combinedIdx] = result;\n      if (!_isPlaceholder(result)) {\n        left -= 1;\n      }\n      combinedIdx += 1;\n    }\n    return left <= 0 ? fn.apply(this, combined)\n                     : _arity(left, _curryN(length, combined, fn));\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/internal/_curryN.js\n// module id = 7\n// module chunks = 0","export * from \"./meiosis\";\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts"],"sourceRoot":""}